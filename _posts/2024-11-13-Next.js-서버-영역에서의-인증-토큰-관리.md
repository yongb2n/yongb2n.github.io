---
title: Next.js 서버 영역에서의 인증 토큰 관리 
date: 2024-11-13 12:15:00 +09:00
categories: [Next, 인증]
tags: [Auth, 인증, 인가, 토큰, API Routes]
---

## 기존 문제점 및 개선 방향

이전 프로젝트에서는 클라이언트 요청마다 인증 토큰을 직접 전송해 백엔드에서 인증을 처리하는 방식이었습니다. 
그러나 다음과 같은 보안적인 취약점이 존재했습니다:
- **클라이언트에서의 토큰 노출 위험**: LocalStorage 또는 SessionStorage에 저장된 토큰이 XSS 공격에 취약함.
- **불필요한 인증 요청 증가**: 클라이언트가 매 요청마다 인증 토큰을 전송하여 서버의 부하 증가.
- **토큰 갱신 처리의 어려움**: 토큰 만료 시 클라이언트에서 직접 갱신 요청을 처리해야 했음.

이를 해결하기 위해 **Next.js API Routes와 Middleware를 활용한 안전한 인증 시스템**을 설계했습니다.

---

## 인증 시스템 설계

### 1. JWT를 HttpOnly 및 Secure 쿠키에 저장

- **HttpOnly** 속성을 사용하여 JavaScript에서 접근할 수 없도록 설정 → XSS 공격 방지
- **Secure** 속성을 적용하여 HTTPS 환경에서만 전송
- **SameSite=Lax**를 설정해 CSRF 공격에 대한 보안 강화

```ts
res.cookies.set('accessToken', accessToken, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  path: '/',
  maxAge: 3600,
})
```

### 2. Next.js API Routes를 활용한 인증 토큰 관리

클라이언트는 직접 백엔드와 통신하지 않고, Next.js API Routes를 통해 중앙에서 인증을 관리하도록 구현했습니다.

#### Access Token 조회 API

```ts
export const GET = async (): Promise<NextResponse> => {
  const accessToken = (await cookies()).get('accessToken')?.value

  if (!accessToken) {
    return NextResponse.json(
      { success: false, message: 'Access token이 존재하지 않습니다.' },
      { status: 401 }
    )
  }

  return NextResponse.json({ success: true, accessToken })
}
```

#### Access Token 갱신 API

```ts
export const POST = async (req: NextRequest): Promise<NextResponse> => {
  const body = await req.json()
  const { oldAccessToken, refreshToken } = body

  try {
    const {
      result: { accessToken },
    } = await backendApi.post('v1/auth/new-token', {
      json: { oldAccessToken, refreshToken },
      headers: {
        Authorization: `Bearer ${refreshToken}`,
      },
    }).json<ApiResponse<AccessTokenResponse>>()

    const res = NextResponse.json({ success: true, result: { accessToken } })

    res.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 1800,
    })

    return res
  } catch (error) {
    return NextResponse.json(
      { success: false, message: '토큰 갱신 실패' },
      { status: 500 }
    )
  }
}
```

### 3. Next.js Middleware를 활용한 인증 상태 확인

API 요청마다 클라이언트에서 인증을 처리하는 대신, Next.js의 **Middleware**를 활용하여 요청이 들어올 때마다 인증 상태를 자동으로 확인하도록 했습니다.

#### Middleware 구현

```ts
export async function middleware(req: NextRequest): Promise<NextResponse> {
  const cookies = req.cookies
  const oldAccessToken = cookies.get('accessToken')?.value as string
  const refreshToken = cookies.get('refreshToken')?.value as string

  if (!oldAccessToken || !refreshToken) {
    return NextResponse.redirect(new URL('/login', req.url))
  }

  try {
    const decodedToken = jwt.decode(oldAccessToken) as { exp?: number }
    const currentTime = Math.floor(Date.now() / 1000)

    if (decodedToken?.exp && decodedToken.exp > currentTime) {
      return NextResponse.next()
    }

    // 토큰이 만료되면, 다시 갱신 시도
    const newTokenResponse = await requestNewToken(oldAccessToken, refreshToken)

    if (newTokenResponse.success) {
      return NextResponse.next()
    } else {
      return NextResponse.redirect(new URL('/login', req.url))
    }
  } catch (error) {
    return NextResponse.redirect(new URL('/login', req.url))
  }
}
```

### 4. 로그아웃 처리

로그아웃 시 토큰을 제거하도록 구현했습니다.

```ts
export const POST = async (): Promise<NextResponse> => {
  try {
    const res = NextResponse.json({ success: true, message: '로그아웃 성공' })

    res.cookies.set('accessToken', '', {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      path: '/',
      maxAge: 0,
    })

    res.cookies.set('refreshToken', '', {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      path: '/',
      maxAge: 0,
    })

    return res
  } catch (error) {
    return NextResponse.json(
      { success: false, message: '로그아웃 실패' },
      { status: 500 }
    )
  }
}
```

---

## 정리 및 기대 효과

**보안 강화**: 토큰을 HttpOnly & Secure 쿠키에 저장하여 XSS 공격을 방지
**API 요청 최적화**: Next.js API Routes를 활용하여 클라이언트가 직접 토큰을 처리하지 않도록 개선
**자동 토큰 갱신**: Middleware에서 토큰이 만료되었을 때 자동으로 갱신 시도
**CSRF 방지**: 쿠키 기반 인증을 사용하면서 `SameSite=Lax` 설정 적용

이 방식으로 인증 시스템을 개선하면 보안성을 강화하면서도 유지보수가 쉬운 구조를 만들 수 있습니다.
